diff --git a/pydantic/__init__.py b/pydantic/__init__.py
index a6eba0329..64e9b03a4 100644
--- a/pydantic/__init__.py
+++ b/pydantic/__init__.py
@@ -112,6 +112,7 @@ __all__ = (
     'PydanticForbiddenQualifier',
     # fields
     'Field',
+    'FractionField',
     'computed_field',
     'PrivateAttr',
     # alias
@@ -280,6 +281,7 @@ _dynamic_imports: 'dict[str, tuple[str, str]]' = {
     'PydanticForbiddenQualifier': (__spec__.parent, '.errors'),
     # fields
     'Field': (__spec__.parent, '.fields'),
+    'FractionField': (__spec__.parent, '.fraction_field'),
     'computed_field': (__spec__.parent, '.fields'),
     'PrivateAttr': (__spec__.parent, '.fields'),
     # alias
diff --git a/pydantic/_internal/_generate_schema.py b/pydantic/_internal/_generate_schema.py
index 50099f77f..785014027 100644
--- a/pydantic/_internal/_generate_schema.py
+++ b/pydantic/_internal/_generate_schema.py
@@ -273,6 +273,28 @@ def apply_each_item_validators(
     return schema
 
 
+def _convert_fraction_examples(examples: Any) -> Any:
+    """"""Convert Fraction examples to JSON-serializable format.""""""
+    if examples is None:
+        return None
+
+    try:
+        return to_jsonable_python(examples)
+    except Exception:
+        if isinstance(examples, list):
+            converted = []
+            for example in examples:
+                if isinstance(example, Fraction):
+                    converted.append(str(example))
+                else:
+                    converted.append(example)
+            return converted
+        elif isinstance(examples, Fraction):
+            return str(examples)
+        else:
+            return examples
+
+
 def _extract_json_schema_info_from_field_info(
     info: FieldInfo | ComputedFieldInfo,
 ) -> tuple[JsonDict | None, JsonDict | JsonSchemaExtraCallable | None]:
@@ -280,7 +302,7 @@ def _extract_json_schema_info_from_field_info(
         'title': info.title,
         'description': info.description,
         'deprecated': bool(info.deprecated) or info.deprecated == '' or None,
-        'examples': to_jsonable_python(info.examples),
+        'examples': _convert_fraction_examples(info.examples),
     }
     json_schema_updates = {k: v for k, v in json_schema_updates.items() if v is not None}
     return (json_schema_updates or None, info.json_schema_extra)
@@ -633,8 +655,11 @@ class GenerateSchema:
                 json_schema=core_schema.no_info_plain_validator_function(fraction_validator),
                 python_schema=core_schema.is_instance_schema(Fraction),
             ),
-            # use str serialization to guarantee round trip behavior
-            serialization=core_schema.to_string_ser_schema(when_used='always'),
+            # Use json_or_python serialization like Decimal - Fraction objects in Python mode, strings in JSON mode
+            serialization=core_schema.json_or_python_schema(
+                json_schema=core_schema.to_string_ser_schema(),
+                python_schema=core_schema.simple_ser_schema('any'),
+            ),
             metadata={'pydantic_js_functions': [lambda _1, _2: {'type': 'string', 'format': 'fraction'}]},
         )
 
diff --git a/pydantic/_internal/_known_annotated_metadata.py b/pydantic/_internal/_known_annotated_metadata.py
index c127e27ac..41fa8d73d 100644
--- a/pydantic/_internal/_known_annotated_metadata.py
+++ b/pydantic/_internal/_known_annotated_metadata.py
@@ -98,6 +98,10 @@ for constraints, schemas in constraint_schema_pairings:
 
 
 def as_jsonable_value(v: Any) -> Any:
+    from fractions import Fraction
+
+    if isinstance(v, Fraction):
+        return str(v)
     if type(v) not in (int, str, float, bytes, bool, type(None)):
         return to_jsonable_python(v)
     return v
diff --git a/pydantic/_internal/_validators.py b/pydantic/_internal/_validators.py
index bf1aabda2..555a4dfa3 100644
--- a/pydantic/_internal/_validators.py
+++ b/pydantic/_internal/_validators.py
@@ -250,9 +250,25 @@ def fraction_validator(input_value: Any, /) -> Fraction:
     if isinstance(input_value, Fraction):
         return input_value
 
+    if input_value is None:
+        raise PydanticCustomError('fraction_parsing', 'Input should be a valid fraction')
+
+    if isinstance(input_value, str):
+        if ' / ' in input_value or input_value.startswith(' ') or input_value.endswith(' '):
+            raise PydanticCustomError('fraction_parsing', 'Input is not a valid fraction')
+
+        if '//' in input_value:
+            raise PydanticCustomError('fraction_parsing', 'Input is not a valid fraction')
+
+        if '/' in input_value:
+            parts = input_value.split('/')
+            if len(parts) == 2:
+                if '.' in parts[0] or '.' in parts[1]:
+                    raise PydanticCustomError('fraction_parsing', 'Input is not a valid fraction')
+
     try:
         return Fraction(input_value)
-    except ValueError:
+    except (ValueError, TypeError, ZeroDivisionError):
         raise PydanticCustomError('fraction_parsing', 'Input is not a valid fraction')
 
 
diff --git a/pydantic/fraction_field.py b/pydantic/fraction_field.py
new file mode 100644
index 000000000..3f64304d4
--- /dev/null
+++ b/pydantic/fraction_field.py
@@ -0,0 +1,65 @@
+""""""Fraction field implementation for Pydantic.""""""
+
+from __future__ import annotations as _annotations
+
+from fractions import Fraction
+from typing import Any
+
+from .fields import Field
+
+
+def FractionField(
+    default: Any = ...,
+    *,
+    gt: Fraction | None = None,
+    ge: Fraction | None = None,
+    lt: Fraction | None = None,
+    le: Fraction | None = None,
+    multiple_of: Fraction | None = None,
+    normalize: bool = True,
+    **kwargs: Any,
+) -> Any:
+    """"""Create a field for Fraction values with proper validation constraints.
+
+    Args:
+        default: Default value for the field
+        gt: Greater than constraint (as Fraction)
+        ge: Greater than or equal constraint (as Fraction)
+        lt: Less than constraint (as Fraction)
+        le: Less than or equal constraint (as Fraction)
+        multiple_of: Multiple of constraint (as Fraction)
+        normalize: Whether to normalize the fraction (default: True)
+        **kwargs: Additional field arguments
+
+    Returns:
+        Field configuration for Fraction validation
+    """"""
+    # Store Fraction constraints in metadata for documentation
+    json_schema_extra = kwargs.get('json_schema_extra', {})
+    if not isinstance(json_schema_extra, dict):
+        json_schema_extra = {}
+
+    json_schema_extra['fraction_constraints'] = {
+        'gt': str(gt) if gt is not None else None,
+        'ge': str(ge) if ge is not None else None,
+        'lt': str(lt) if lt is not None else None,
+        'le': str(le) if le is not None else None,
+        'multiple_of': str(multiple_of) if multiple_of is not None else None,
+        'normalize': normalize,
+    }
+    kwargs['json_schema_extra'] = json_schema_extra
+
+    # Pass Fraction constraints directly - no conversion to float
+    # This preserves exact rational arithmetic as required by the review
+    if gt is not None:
+        kwargs['gt'] = gt
+    if ge is not None:
+        kwargs['ge'] = ge
+    if lt is not None:
+        kwargs['lt'] = lt
+    if le is not None:
+        kwargs['le'] = le
+    if multiple_of is not None:
+        kwargs['multiple_of'] = multiple_of
+
+    return Field(default, **kwargs)
diff --git a/pydantic/json_schema.py b/pydantic/json_schema.py
index 0873440c1..e5138eb69 100644
--- a/pydantic/json_schema.py
+++ b/pydantic/json_schema.py
@@ -2257,6 +2257,10 @@ class GenerateJsonSchema:
             The encoded default value.
         """"""
         from .type_adapter import TypeAdapter, _type_has_config
+        from fractions import Fraction
+
+        if isinstance(dft, Fraction):
+            return str(dft)
 
         config = self._config
         try:
