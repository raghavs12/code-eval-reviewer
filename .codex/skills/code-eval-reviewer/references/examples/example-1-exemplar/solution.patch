diff --git a/fastapi/applications.py b/fastapi/applications.py
index 6db4b4e8..fc5d9c67 100644
--- a/fastapi/applications.py
+++ b/fastapi/applications.py
@@ -32,6 +32,7 @@ from fastapi.openapi.utils import get_openapi
 from fastapi.params import Depends
 from fastapi.types import DecoratedCallable, IncEx
 from fastapi.utils import generate_unique_id
+from pydantic import BaseModel
 from starlette.applications import Starlette
 from starlette.datastructures import State
 from starlette.exceptions import HTTPException
@@ -1163,6 +1164,7 @@ class FastAPI(Starlette):
         generate_unique_id_function: Callable[[routing.APIRoute], str] = Default(
             generate_unique_id
         ),
+        response_headers: Optional[Type[BaseModel]] = None,
     ) -> None:
         self.router.add_api_route(
             path,
@@ -1189,6 +1191,7 @@ class FastAPI(Starlette):
             name=name,
             openapi_extra=openapi_extra,
             generate_unique_id_function=generate_unique_id_function,
+            response_headers=response_headers,
         )
 
     def api_route(
@@ -1219,6 +1222,7 @@ class FastAPI(Starlette):
         generate_unique_id_function: Callable[[routing.APIRoute], str] = Default(
             generate_unique_id
         ),
+        response_headers: Optional[Type[BaseModel]] = None,
     ) -> Callable[[DecoratedCallable], DecoratedCallable]:
         def decorator(func: DecoratedCallable) -> DecoratedCallable:
             self.router.add_api_route(
@@ -1246,6 +1250,7 @@ class FastAPI(Starlette):
                 name=name,
                 openapi_extra=openapi_extra,
                 generate_unique_id_function=generate_unique_id_function,
+                response_headers=response_headers,
             )
             return func
 
@@ -1867,6 +1872,14 @@ class FastAPI(Starlette):
                 """
             ),
         ] = Default(generate_unique_id),
+        response_headers: Annotated[
+            Optional[Type[BaseModel]],
+            Doc(
+                """
+                A Pydantic model to validate and document response headers.
+                """
+            ),
+        ] = None,
     ) -> Callable[[DecoratedCallable], DecoratedCallable]:
         """
         Add a *path operation* using an HTTP GET operation.
@@ -1907,6 +1920,7 @@ class FastAPI(Starlette):
             callbacks=callbacks,
             openapi_extra=openapi_extra,
             generate_unique_id_function=generate_unique_id_function,
+            response_headers=response_headers,
         )
 
     def put(
diff --git a/fastapi/routing.py b/fastapi/routing.py
index fe25d7de..0ad231c6 100644
--- a/fastapi/routing.py
+++ b/fastapi/routing.py
@@ -304,6 +304,7 @@ def get_request_handler(
     response_model_exclude_none: bool = False,
     dependency_overrides_provider: Optional[Any] = None,
     embed_body_fields: bool = False,
+    response_headers_field: Optional[ModelField] = None,
 ) -> Callable[[Request], Coroutine[Any, Any, Response]]:
     assert dependant.call is not None, "dependant.call must be a function"
     is_coroutine = iscoroutinefunction(dependant.call)
@@ -429,6 +430,54 @@ def get_request_handler(
             )
             raise validation_error
 
+        # Validate and set response headers if response_headers_field is defined
+        if response_headers_field:
+            # Create a case-insensitive dict for validation (HTTP headers are case-insensitive)
+            headers_dict_lower = {k.lower(): v for k, v in response.headers.items()}
+            # Get the expected field names from the model
+            from fastapi._compat import get_cached_model_fields
+            model_fields = get_cached_model_fields(response_headers_field.type_)
+            # Map model field aliases to actual header values (case-insensitive)
+            headers_for_validation = {}
+            for field in model_fields:
+                field_alias = field.alias if field.alias != field.name else field.name
+                # Look for the header in a case-insensitive manner
+                header_value = None
+                for header_key, header_val in response.headers.items():
+                    if header_key.lower() == field_alias.lower():
+                        header_value = header_val
+                        break
+                if header_value is not None:
+                    headers_for_validation[field_alias] = header_value
+            
+            headers_errors = []
+            value, errors_ = response_headers_field.validate(headers_for_validation, {}, loc=("response", "headers"))
+            if isinstance(errors_, list):
+                headers_errors.extend(errors_)
+            elif errors_:
+                headers_errors.append(errors_)
+            if headers_errors:
+                raise ResponseValidationError(
+                    errors=_normalize_errors(headers_errors), body=headers_for_validation
+                )
+            # Update response headers with validated values (includes type coercion)
+            if hasattr(response_headers_field, "serialize"):
+                validated_headers = response_headers_field.serialize(
+                    value,
+                    by_alias=True,
+                    exclude_unset=True,
+                )
+            else:
+                validated_headers = jsonable_encoder(
+                    value,
+                    by_alias=True,
+                    exclude_unset=True,
+                )
+            # Set validated headers on response
+            for header_name, header_value in validated_headers.items():
+                if header_value is not None:
+                    response.headers[header_name] = str(header_value)
+
         # Return response
         assert response
         return response
@@ -537,6 +586,7 @@ class APIRoute(routing.Route):
         generate_unique_id_function: Union[
             Callable[["APIRoute"], str], DefaultPlaceholder
         ] = Default(generate_unique_id),
+        response_headers: Optional[Type[BaseModel]] = None,
     ) -> None:
         self.path = path
         self.endpoint = endpoint
@@ -563,6 +613,7 @@ class APIRoute(routing.Route):
         self.callbacks = callbacks
         self.openapi_extra = openapi_extra
         self.generate_unique_id_function = generate_unique_id_function
+        self.response_headers = response_headers
         self.tags = tags or []
         self.responses = responses or {}
         self.name = get_name(endpoint) if name is None else name
@@ -605,6 +656,18 @@ class APIRoute(routing.Route):
         else:
             self.response_field = None  # type: ignore
             self.secure_cloned_response_field = None
+        
+        # Create field for response headers validation
+        if self.response_headers:
+            headers_name = "ResponseHeaders_" + self.unique_id
+            self.response_headers_field = create_model_field(
+                name=headers_name,
+                type_=self.response_headers,
+                mode="serialization",
+            )
+        else:
+            self.response_headers_field = None  # type: ignore
+        
         self.dependencies = list(dependencies or [])
         self.description = description or inspect.cleandoc(self.endpoint.__doc__ or "")
         # if a "form feed" character (page break) is found in the description text,
@@ -661,6 +724,7 @@ class APIRoute(routing.Route):
             response_model_exclude_none=self.response_model_exclude_none,
             dependency_overrides_provider=self.dependency_overrides_provider,
             embed_body_fields=self._embed_body_fields,
+            response_headers_field=self.response_headers_field,
         )
 
     def matches(self, scope: Scope) -> Tuple[Match, Scope]:
@@ -989,6 +1053,7 @@ class APIRouter(routing.Router):
         generate_unique_id_function: Union[
             Callable[[APIRoute], str], DefaultPlaceholder
         ] = Default(generate_unique_id),
+        response_headers: Optional[Type[BaseModel]] = None,
     ) -> None:
         route_class = route_class_override or self.route_class
         responses = responses or {}
@@ -1035,6 +1100,7 @@ class APIRouter(routing.Router):
             callbacks=current_callbacks,
             openapi_extra=openapi_extra,
             generate_unique_id_function=current_generate_unique_id,
+            response_headers=response_headers,
         )
         self.routes.append(route)
 
@@ -1067,6 +1133,7 @@ class APIRouter(routing.Router):
         generate_unique_id_function: Callable[[APIRoute], str] = Default(
             generate_unique_id
         ),
+        response_headers: Optional[Type[BaseModel]] = None,
     ) -> Callable[[DecoratedCallable], DecoratedCallable]:
         def decorator(func: DecoratedCallable) -> DecoratedCallable:
             self.add_api_route(
@@ -1095,6 +1162,7 @@ class APIRouter(routing.Router):
                 callbacks=callbacks,
                 openapi_extra=openapi_extra,
                 generate_unique_id_function=generate_unique_id_function,
+                response_headers=response_headers,
             )
             return func
 
@@ -1772,6 +1840,14 @@ class APIRouter(routing.Router):
                 """
             ),
         ] = Default(generate_unique_id),
+        response_headers: Annotated[
+            Optional[Type[BaseModel]],
+            Doc(
+                """
+                A Pydantic model to validate and document response headers.
+                """
+            ),
+        ] = None,
     ) -> Callable[[DecoratedCallable], DecoratedCallable]:
         """
         Add a *path operation* using an HTTP GET operation.
@@ -1816,6 +1892,7 @@ class APIRouter(routing.Router):
             callbacks=callbacks,
             openapi_extra=openapi_extra,
             generate_unique_id_function=generate_unique_id_function,
+            response_headers=response_headers,
         )
 
     def put(
